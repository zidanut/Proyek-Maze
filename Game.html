<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset=utf-8 />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <title>Test</title>
        <style>
            body { margin: 0; overflow: hidden; }
            canvas { display: block; }
		#loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            font-size: 2em;
            z-index: 10;
        }
        #container {
            display: none;
        }
          </style>
	</head>
	<body>
		<div id="loading">Loading...</div>
		<div id="container"></div>

        <script type="importmap">
            {
              "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
				"three-pathfinding": "./libs/three-pathfinding.umd.js"
              }
            }
        </script>

		<script type="module">
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { Octree } from 'three/addons/math/Octree.js';
			import { Capsule } from 'three/addons/math/Capsule.js';
			import { Pathfinding } from 'three-pathfinding';

			const clock = new THREE.Clock();
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x151515);
			scene.fog = new THREE.Fog( 0x0C0C0C, 0, 50 );

			const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.rotation.order = 'YXZ';

			const ambientLight = new THREE.AmbientLight(0xffffff, 0.04);
			scene.add(ambientLight);

			const senter = new THREE.SpotLight(0xffffff);
			senter.intensity = 0.6;
			senter.angle = Math.PI/8;
			senter.penumbra = 0.3;
			senter.distance = 5;
			senter.decay = 1;
			senter.castShadow = true;
			scene.add(senter);
			let SenterNyala = false;

			const container = document.getElementById( 'container' );
			const loadingScreen = document.getElementById('loading');

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.toneMapping = THREE.NoToneMapping;//kalau hndk bagus ganti jadi "NeutralToneMapping"/"ACESFilmicToneMappin"g
			container.appendChild( renderer.domElement );

			const GRAVITY = 30;
			const STEPS_PER_FRAME = 5;

			const worldOctree = new Octree();

			const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35,0  ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();

			let playerOnFloor = false;

			const keyStates = {};

			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();

			document.addEventListener('keydown', (event) => {
				keyStates[event.code] = true;
				if (event.code === 'KeyF') {
					SenterNyala = !SenterNyala;
					senter.visible = SenterNyala;
				}
			});

			document.addEventListener('keyup', (event) => {
				keyStates[event.code] = false;
			});

			container.addEventListener('mousedown', () => {
				document.body.requestPointerLock();
			} );

			// document.addEventListener('mouseup', () => {
			// 	nanti kalau ada
			// } );

			document.body.addEventListener('mousemove', (event) => {
				if (document.pointerLockElement === document.body) {
					camera.rotation.y -= event.movementX / 500;
					camera.rotation.x -= event.movementY / 500;
				}
			} );

			window.addEventListener('resize', onWindowResize);

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function playerCollisions() {
				const result = worldOctree.capsuleIntersect(playerCollider);
				playerOnFloor = false;
				if (result) {
					playerOnFloor = result.normal.y > 0;
					if (!playerOnFloor) {
						playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
					}
					playerCollider.translate(result.normal.multiplyScalar(result.depth));
				}
			}

			function updatePlayer(deltaTime) {
				let damping = Math.exp(-4 * deltaTime) -1;
				if (!playerOnFloor) {
					playerVelocity.y -= GRAVITY * deltaTime;
					damping *= 0.1;
				}
				playerVelocity.addScaledVector(playerVelocity, damping);
				const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
				playerCollider.translate(deltaPosition);
				playerCollisions();
				camera.position.copy(playerCollider.end);
			}

			function updateSenter() {
            	senter.position.copy(camera.position);
            	senter.target.position.copy(camera.position).add(camera.getWorldDirection(playerDirection));
            	senter.target.updateMatrixWorld();
        	}

			function getForwardVector() {
				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				return playerDirection;
			}

			function getSideVector() {
				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( camera.up );
				return playerDirection;
			}

			function controls(deltaTime) {
				const speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );
				if (keyStates['KeyW']){
					playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
				}
				if (keyStates['KeyS']){
					playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
				}
				if (keyStates['KeyA']){
					playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
				}
				if (keyStates['KeyD']){
					playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
				}
			}
			const loader = new GLTFLoader();
			loader.load('labirin1.glb', (gltf) => {
				scene.add(gltf.scene);
				worldOctree.fromGraphNode(gltf.scene);
				gltf.scene.traverse(child => {
					if (child.isMesh) {
						child.castShadow = false;
						child.receiveShadow = false;
						if (child.material.map) {
							child.material.map.anisotropy = 4;
						}
					}
				});
				loadingScreen.style.display = 'none';
				container.style.display = 'block';
			});

			function teleportPlayerIfOob() {
				if (camera.position.y <= -25) {
					playerCollider.start.set(0, 0.35, 0);
					playerCollider.end.set(0, 1, 0);
					playerCollider.radius = 0.35;
					camera.position.copy(playerCollider.end);
					camera.rotation.set(0, 0, 0);
				}
			}
			let pathfinding = new Pathfinding();
			const ZONE = 'level1';
			const navMeshUrl = 'labirin1NavMesh.glb';

			const waypoints = [
			new THREE.Vector3(-9.8, 0, 10.3),
			new THREE.Vector3(-16.8, 0, 21.8),
			new THREE.Vector3(-0.2, 0, 5.5),
			new THREE.Vector3(-21.5, 0, 0.67),
			//tempat yang akan didatangi monster
			];

			const monsterStartPositions = [
			new THREE.Vector3(-21, 0, 0.5),
			new THREE.Vector3(-2.5, 0, 2.8),
			new THREE.Vector3(-16.6, 0, 14.7),
			//Tambahkan jika ingin menambahkan lebih banyak monster dan posisinya
			];

			const monsters = [];
			const mixers = [];
			const monsterPaths = [];
			const monsterPathIndices = [];
			const waypointIndices = [];

			loader.load(navMeshUrl, (gltf) => {
				const navMesh = gltf.scene;
				pathfinding.setZoneData(ZONE, Pathfinding.createZone(navMesh));

				monsterStartPositions.forEach((startPosition, index) => {
					loader.load('monster.glb', (gltf) => {
						const monster = gltf.scene;
						monster.position.copy(startPosition);
						scene.add(monster);
						monsters.push(monster);

						const mixer = new THREE.AnimationMixer(monster);
						mixers.push(mixer);
						const walkAnimation = gltf.animations.find(anim => anim.name === 'anim');
						const monsterAction = mixer.clipAction(walkAnimation);
						monsterAction.play();

						waypointIndices[index] = 0;
						monsterPaths[index] = [];
						findNextPath(index);
					});
				});
			});

			function findNextPath(monsterIndex) {
				waypointIndices[monsterIndex] = (waypointIndices[monsterIndex] + 1) % waypoints.length;
				const targetPosition = waypoints[waypointIndices[monsterIndex]];
				monsterPaths[monsterIndex] = pathfinding.findPath(monsters[monsterIndex].position, targetPosition, ZONE, 1);
				monsterPathIndices[monsterIndex] = 0;
			}

			function moveMonster(deltaTime, monsterIndex) {
				const monster = monsters[monsterIndex];
				const path = monsterPaths[monsterIndex];
				let pathIndex = monsterPathIndices[monsterIndex];

				if (path && path.length) {
					const targetPosition = path[pathIndex];
					const direction = targetPosition.clone().sub(monster.position).normalize();
					const moveDistance = 2 * deltaTime;  // Adjust speed here
					monster.position.add(direction.multiplyScalar(moveDistance));

					if (monster.position.distanceTo(targetPosition) < 0.1) {
						pathIndex++;
						if (pathIndex >= path.length) {
							findNextPath(monsterIndex);
						}
					}
					monsterPathIndices[monsterIndex] = pathIndex;
				}
			}
			function animate() {
				const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
				for (let i = 0; i < STEPS_PER_FRAME; i++) {
					controls(deltaTime);
					updatePlayer(deltaTime);
					teleportPlayerIfOob();
				}
				updateSenter();

				mixers.forEach((mixer, index) => {
				mixer.update(clock.getDelta());
				moveMonster(clock.getDelta(), index);
				});

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>